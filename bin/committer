#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'open3'
require 'httparty'
require 'yaml'
require_relative '../lib/committer/config'
require_relative '../lib/committer/prompt_templates'
require_relative '../lib/clients/claude_client'

# Handle command line arguments
command = ARGV[0]

case command
when 'setup'
  Committer::Config.setup
  exit 0

when 'help', '--help', '-h'
  puts 'Committer - AI-powered git commit message generator'
  puts
  puts 'Commands:'
  puts '  committer setup  - Create the config file template at ~/.committer/config.yml'
  puts '  committer        - Generate commit message for staged changes'
  puts
  exit 0
end

# Default behavior: generate commit message
def build_commit_prompt(diff, commit_context = nil)
  scopes = Committer::Config.load
  scope_section = scopes.empty? ? '' : "\nScopes:\n#{scopes.map { |s| "- #{s}" }.join("\n")}"
  scope_instruction = if scopes.empty?
                        '- DO NOT include a scope in your commit message'
                      else
                        '- Choose an appropriate scope from the list above if relevant to the change'
                      end
  format(template(commit_context),
         diff: diff,
         scopes_section: scope_section,
         scope_instruction: scope_instruction,
         commit_context: commit_context)
end

def template(commit_context)
  if commit_context.nil? || commit_context.empty?
    Committer::PromptTemplates::SUMMARY_ONLY
  else
    Committer::PromptTemplates::SUMMARY_AND_BODY
  end
end

def check_git_status
  stdout, stderr, status = Open3.capture3('git diff --staged')

  unless status.success?
    puts 'Error executing git diff --staged:'
    puts stderr
    exit 1
  end

  if stdout.empty?
    puts 'No changes are staged for commit.'
    exit 0
  end

  stdout
end

def parse_response(response, commit_context)
  text = response.dig('content', 0, 'text')

  # If user didn't provide context, response should only be a summary line
  if commit_context.nil? || commit_context.empty?
    { summary: text.strip, body: nil }
  else
    # Split the response into summary and body
    message_parts = text.split("\n\n", 2)
    summary = message_parts[0].strip
    body = message_parts[1]&.strip

    # Wrap body text at 80 characters
    body = body.gsub(/(.{1,80})(\s+|$)/, "\\1\n").strip if body

    { summary: summary, body: body }
  end
end

def prepare_commit_message(diff, commit_context = nil)
  client = Clients::ClaudeClient.new
  puts 'Sending diff to Claude...'

  prompt = build_commit_prompt(diff, commit_context)
  response = client.post(prompt)
  parse_response(response, commit_context)
end

def execute_git_diff_staged
  diff = check_git_status

  # Prompt user for commit context
  puts 'Why are you making this change? (Press Enter to skip)'
  commit_context = gets.chomp

  commit_message = prepare_commit_message(diff, commit_context)

  summary = commit_message[:summary]
  body = commit_message[:body]

  # Create git commit with the suggested message and open in editor
  if body
    system('git', 'commit', '-m', summary, '-m', body, '-e')
  else
    system('git', 'commit', '-m', summary, '-e')
  end
rescue Clients::ClaudeClient::ConfigError, StandardError => e
  puts "Error: #{e.message}"
  exit 1
end

# Execute the function if no specific command was given
execute_git_diff_staged
